#pragma once

////////////////////////////////////////////////////////////////////////////////////////
namespace react {

////////////////////////////////////////////////////////////////////////////////////////
/// ReactiveObject
////////////////////////////////////////////////////////////////////////////////////////
template <typename D>
class ReactiveObject
{
public:
	////////////////////////////////////////////////////////////////////////////////////////
	/// Aliases
	////////////////////////////////////////////////////////////////////////////////////////
	template <typename S>
	using Signal = RSignal<D,S>;

	template <typename S>
	using VarSignal = RVarSignal<D,S>;

	template <typename E = EventToken>
	using Events = REvents<D,E>;

	template <typename E = EventToken>
	using EventSource = REventSource<D,E>;

	using Observer = RObserver<D>;

	////////////////////////////////////////////////////////////////////////////////////////
	/// MakeVar
	////////////////////////////////////////////////////////////////////////////////////////
	template
	<
		typename V,
		typename S = std::decay<V>::type,
		class = std::enable_if<
			!IsSignalT<D,S>::value>::type
	>
	static inline auto MakeVar(V&& value)
		-> VarSignal<S>
	{
		return react::MakeVar<D>(std::forward<V>(value));
	}

	//////////////////////////////////////////////////////////////////////////////////////
	// MakeVar (higher order signal)
	//////////////////////////////////////////////////////////////////////////////////////
	template
	<
		typename V,
		typename S = std::decay<V>::type,
		typename TInner = S::ValueT,
		class = std::enable_if<
			IsSignalT<D,S>::value>::type
	>
	static inline auto MakeVar(V&& value)
		-> VarSignal<Signal<TInner>>
	{
		return react::MakeVar<D>(std::forward<V>(value));
	}

	////////////////////////////////////////////////////////////////////////////////////////
	/// MakeSignal
	////////////////////////////////////////////////////////////////////////////////////////
	template
	<
		typename TFunc,
		typename ... TArgs
	>
	static inline auto MakeSignal(TFunc func, const Signal<TArgs>& ... args)
		-> Signal<decltype(func(args() ...))>
	{
		typedef decltype(func(args() ...)) S;

		return react::MakeSignal<D>(func, args ...);
	}

	////////////////////////////////////////////////////////////////////////////////////////
	/// MakeEventSource
	////////////////////////////////////////////////////////////////////////////////////////
	template <typename E>
	static inline auto MakeEventSource()
		-> EventSource<E>
	{
		return react::MakeEventSource<D,E>();
	}

	////////////////////////////////////////////////////////////////////////////////////////
	/// DYNAMIC_REF
	////////////////////////////////////////////////////////////////////////////////////////
	#define DYNAMIC_REF(obj, name)	\
	Flatten(						\
		MakeSignal(					\
			[] (Identity<decltype(obj)>::Type::ValueT r) { return r->name; }, obj))
};

} //~namespace react